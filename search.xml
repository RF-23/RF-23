<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HEXO建站经验分享</title>
    <url>/2019/12/10/HEXO%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="HEXO建立个人博客经验分享"><a href="#HEXO建立个人博客经验分享" class="headerlink" title="HEXO建立个人博客经验分享"></a>HEXO建立个人博客经验分享</h2><h3 id="前言：NOIP2018前年某天同机房的神仙想我推荐了HEXO，亲身体验后发现它确实是一款很不错的博客构架"><a href="#前言：NOIP2018前年某天同机房的神仙想我推荐了HEXO，亲身体验后发现它确实是一款很不错的博客构架" class="headerlink" title="前言：NOIP2018前年某天同机房的神仙想我推荐了HEXO，亲身体验后发现它确实是一款很不错的博客构架"></a>前言：NOIP2018前年某天同机房的神仙想我推荐了HEXO，亲身体验后发现它确实是一款很不错的博客构架</h3><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>参考<a href="https://hexo.io/">HEXO</a>官方，我们可以很容易的建立了解HEXO的使用方法<br>这里主要记录我在建自己的博客时候遇到的雷点</p>
<h3 id="1-正确安装换环境"><a href="#1-正确安装换环境" class="headerlink" title="#1 正确安装换环境"></a>#1 正确安装换环境</h3><p>HEXO必备的环境 ： <a href="https://nodejs.org/en/">node.js</a>&ensp;&ensp;&amp; &ensp; <a href="https://git-scm.com/">git</a>  </p>
<h3 id="2-对于主题的选择"><a href="#2-对于主题的选择" class="headerlink" title="#2 对于主题的选择"></a>#2 对于主题的选择</h3><p>按照官方指示正确建立了本地文件之后，选择一个合适且美观的主题是当务之急 <del>默认主题过于难看</del><br>但每个主题区别不仅仅在于美观的界面UI，在使用过程中最容易遇到的问题就是不同主题对于不同功能的支持  </p>
<h4 id="1-选择主题模板前仔细观察-config-文件"><a href="#1-选择主题模板前仔细观察-config-文件" class="headerlink" title="#1 选择主题模板前仔细观察 _config 文件"></a>#1 选择主题模板前仔细观察 _config 文件</h4><p>因为基本上在 _config中包含了所有的主体集成的插件的配置选项<br>例如我选用的 <strong>diaspora</strong> 中不支持MathJax，造成了一系列的麻烦。</p>
<h4 id="2-尽量选用更多人使用的主题模板"><a href="#2-尽量选用更多人使用的主题模板" class="headerlink" title="#2 尽量选用更多人使用的主题模板"></a>#2 尽量选用更多人使用的主题模板</h4><p>显而易见的原因就是，使用过程中，你的先辈们几乎遇到了你能遇到的全部问题，并且已经形成了成熟的解决方案。</p>
<h4 id="3-FireFox-Yes-Chrome-NO"><a href="#3-FireFox-Yes-Chrome-NO" class="headerlink" title="#3 FireFox Yes!!! Chrome NO!"></a>#3 FireFox Yes!!! Chrome NO!</h4><p>一定一定一定一定要使用火狐啊<br>chrome虽然好用,但已经出现了种种兼容性问题，但这些问题都不大<br>最严重的事情在于，过多的插件和使用代理会造成严重问题，诸如本地端口占用等…</p>
<h3 id="3-视频-amp-图片服务器的选择"><a href="#3-视频-amp-图片服务器的选择" class="headerlink" title="#3 视频 \&amp; 图片服务器的选择"></a>#3 视频 \&amp; 图片服务器的选择</h3><h4 id="1-尽量使用png格式图片"><a href="#1-尽量使用png格式图片" class="headerlink" title="#1 尽量使用png格式图片"></a>#1 尽量使用png格式图片</h4><p>不要问我为什么，问就是小</p>
<h4 id="2-不要使用bilibili作为视频服务器"><a href="#2-不要使用bilibili作为视频服务器" class="headerlink" title="#2 不要使用bilibili作为视频服务器"></a>#2 不要使用bilibili作为视频服务器</h4><p>虽然我很喜欢它，但是如果它只有360P的话…<br>ps:实话说我也没有啥好的地方能放视频，听说放在百度贴吧不错，现在用的lofter隔三差五的换视频链接…</p>
<h3 id="4-如果想要解析到自己的域名不要忘记创建-CNAME文件"><a href="#4-如果想要解析到自己的域名不要忘记创建-CNAME文件" class="headerlink" title="#4 如果想要解析到自己的域名不要忘记创建 CNAME文件"></a>#4 如果想要解析到自己的域名不要忘记创建 CNAME文件</h3>]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>HelloWorld</title>
    <url>/2018/10/11/HelloWorld/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="第一篇博客啦"><a href="#第一篇博客啦" class="headerlink" title="第一篇博客啦"></a>第一篇博客啦</h2><p>当做测试吧反正也没人看到 <del>(还没部署呢)</del><br>好吧显然是有人看到了，但是这个东西有点问题，就是markdown源码会被直接显示在文章摘要里面…<br>我哭辽…<br>总之献上线段树板子祭天</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _TP&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_TP &amp;X)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;<span class="keyword">int</span> w;X=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;w=ch==<span class="string">&#x27;-&#x27;</span>;ch=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">	X=w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> sum,lag;</span><br><span class="line">&#125;t[inf&lt;&lt;<span class="number">2</span>]; </span><br><span class="line"><span class="keyword">int</span> a[inf];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>].lag+=t[k].lag;</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lag+=t[k].lag;</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>].sum+=t[k].lag*(t[k&lt;&lt;<span class="number">1</span>].r-t[k&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=t[k].lag*(t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">	t[k].lag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	t[k].l=l;</span><br><span class="line">	t[k].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		t[k].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>,l,m);</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,m+<span class="number">1</span>,r);</span><br><span class="line">	t[k].sum=t[k&lt;&lt;<span class="number">1</span>].sum+t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r,<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r)&#123;</span><br><span class="line">		t[k].lag+=x;</span><br><span class="line">		t[k].sum+=x*(t[k].r-t[k].l+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[k].lag)push_down(k);</span><br><span class="line">	<span class="keyword">int</span> m=(t[k].l+t[k].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=m)change(k&lt;&lt;<span class="number">1</span>,l,r,x);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;m)change(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x);</span><br><span class="line">	t[k].sum=t[k&lt;&lt;<span class="number">1</span>].sum+t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r)&#123;</span><br><span class="line">		ans+=t[k].sum;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[k].lag)push_down(k);</span><br><span class="line">	<span class="keyword">int</span> m=(t[k].r+t[k].l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=m)sum(k&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;m)sum(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n,x,l,r,q;</span><br><span class="line">	<span class="keyword">int</span> opt;</span><br><span class="line">	read(n);read(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		read(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		read(opt);</span><br><span class="line">		<span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				read(l);read(r);read(x);</span><br><span class="line">				change(<span class="number">1</span>,l,r,x);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				read(l);read(r);</span><br><span class="line">				ans=<span class="number">0</span>;</span><br><span class="line">				sum(<span class="number">1</span>,l,r);</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然还要有 helloworld</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>祭@RedForest的建站祭</title>
    <url>/2021/12/12/whoami/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="whoami-ensp"><a href="#whoami-ensp" class="headerlink" title="whoami &ensp;"></a>whoami &ensp;</h2><p>hi 亲爱的朋友，里面请，你可以叫我 RED_FOREST ，祝你愉快  </p>
<p><del>正经点</del>  </p>
<p>我叫李泓霖，现就读于山东省实验中学，曾担任校学生团总支信息技术部副部长<br>初中自学python<br>高中期间曾从事信息学奥赛<br>OIer，曾获 NOIP2018(全国青少年信息学奥林匹克联赛)省三等奖，CSP-S 2019省二等奖(<del>原NOIP</del>)&ensp; <del>现已退役</del><br>同学们都叫我算法大师(法师) <del>好奇怪</del></p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本站建于2018年12月<br>高中三年，总要留下点什么，故而建站。<br>人生几十年，总要留下点什么，不求青史留名，也要证明自己活过  </p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>暂时有点小BUG:数学公式渲染不出来，有时间将进行修复</p>
<h2 id="先定一个能达到的小目标-比方说我先挣它一个亿-拿到中传合格证！！！！"><a href="#先定一个能达到的小目标-比方说我先挣它一个亿-拿到中传合格证！！！！" class="headerlink" title="先定一个能达到的小目标 比方说我先挣它一个亿 拿到中传合格证！！！！"></a>先定一个能达到的小目标 <del>比方说我先挣它一个亿</del> 拿到中传合格证！！！！</h2><h2 id="高考加油！！！"><a href="#高考加油！！！" class="headerlink" title="高考加油！！！"></a>高考加油！！！</h2>]]></content>
      <tags>
        <tag>web</tag>
        <tag>算法</tag>
        <tag>杂项</tag>
        <tag>杂谈</tag>
        <tag>数字媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>OI常数优化技巧</title>
    <url>/2019/10/02/OI%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="常数优化"><a href="#常数优化" class="headerlink" title="常数优化"></a>常数优化</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在oi中，常数优化可谓极其重要<br>当然，不只是oi，常数优化一定程度上组成了代码风格<br>所以说，如何进行常数优化呢？<br>下面就简单的介绍我常用的几个常数优化技巧</p>
<h3 id="1习惯使用-const-…"><a href="#1习惯使用-const-…" class="headerlink" title="#1习惯使用 const …"></a>#1习惯使用 const …</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;d,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;d=a;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    exgcd(b,a%b,d,y,x);y-=x*(a/b);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>const的最大作用就是减少参数传递的时间。</p>
<h3 id="2-不要递归！！"><a href="#2-不要递归！！" class="headerlink" title="#2 不要递归！！"></a>#2 不要递归！！</h3><p>用基础算法算法gcd来举例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b)<span class="keyword">return</span> a;</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">return</span>  gcd(b,a%b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>相信很多人习惯于这种写法<br>但是又一个很严重的问题：在每次递归调用函数的时候,程序都会在栈中新建空间来存放递归函数里的变量，这无疑造成了极大的性能损失，不同于前一个，减少递归而使用迭代能够造成可观的优化。<br>所以说：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t%b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3习惯于将变量声明在循环外"><a href="#3习惯于将变量声明在循环外" class="headerlink" title="#3习惯于将变量声明在循环外"></a>#3习惯于将变量声明在循环外</h3><p>定义变量意味着系统在内存条里找出一块地方让你存数据，想想cpu到内存条之间长长的距离 <del>还有你那不怎么好的主板</del> 特别是在使用AMD处理器（非Zen构架）的情况下<br>所以说对于上面 #2 的程序而言<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        t=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t%b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样或许才是更优美的写法</p>
<h3 id="4-使用-inline"><a href="#4-使用-inline" class="headerlink" title="#4 使用 inline"></a>#4 使用 inline</h3><p>inline可以让你的非递归函数（此函数里不再调用其他函数）编译在原函数中而非另外开栈内存<br>所以对于 #3 的程序我们可以稍加修改<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> t;</span><br><span class="line">     <span class="keyword">while</span>(b)&#123;</span><br><span class="line">         t=a;</span><br><span class="line">         a=b;</span><br><span class="line">         b=t%b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;gcd(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>比如在main()中调用<br>这段代码就相当于<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">4</span>,b=<span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">int</span> t=a;</span><br><span class="line">		a=b;</span><br><span class="line">		b=t%b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-register"><a href="#5-register" class="headerlink" title="#5 register"></a>#5 register</h3><p>前文中说到，每当你定义一个变量或函数，抑或修改变量维护数据，程序都会不远万里的请内存条帮你完成这项工作，而物理上cpu到内存插槽之间的距离一定程度也影响车cpu和内存交互的速度。<br>能不能缩短这个距离呢？答案是肯定的。<br>别忘了我们的cpu里近1/2的面积都是缓存啊<br>直接把变量开在L3缓存里不就不用不远万里找内存条了嘛<br>所以：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAXN;)&#123;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要比<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAXN;)&#123;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>快了将近十倍（亲测）</p>
<h4 id="但有两点点要注意"><a href="#但有两点点要注意" class="headerlink" title="但有两点点要注意"></a>但有两点点要注意</h4><p>其一：众所周知，CPU L3缓存很快，但也很小所以最多能够有让你开几个变量的空间，所以不要随意挥霍register<br>其二：如果你是在<a href="https://www.luogu.org/problem/P3370">LUOGU</a>这样的online judge网站上测试程序，那么我十分不建议使用register。<br>具体原因尚不清楚，但我猜测大概是由于服务器L3缓存使用频繁，很可能已经占满了，这个时候cpu可能又回去找内存条，耽误时间。</p>
<h3 id="6-正确使用STL库函数"><a href="#6-正确使用STL库函数" class="headerlink" title="#6 正确使用STL库函数"></a>#6 正确使用STL库函数</h3><p>STL慢是众所周知的事情，原因是STL中有大量的防止出错的检查项，拉低了速度<br>但即便如此STL函数的算法也是极其优秀的<br>例如你要求log2(5)。<br>一种方法是自己写二分法，复杂度是o(log(p)),p为精确位数，而STL中的log函数使用牛顿迭代，时间复杂度几乎是o(1)如果是这样不如选用STL。<br>然而，诸如 vector 一类的容器常数就非常的大，甚至于到了影响成绩的程度，尽量不要使用。<br>但是如果使用不当,就很容易对程序的性能造成负面影响</p>
<h3 id="7-访问连续内存（链表-NO！）"><a href="#7-访问连续内存（链表-NO！）" class="headerlink" title="#7 访问连续内存（链表 NO！）"></a>#7 访问连续内存（链表 NO！）</h3><p>与其说这是个技巧不如说这是个思想<br>在图论当中，人们常常使用 链式前向星 或 邻接表 或 vector 来存储图<br>在这三者中，理论上vector的时间复杂度最低（只是理论上），因为观察使用方法不难发现前两者是链表结构，而vector是数组。<br>在内存当中，如果我们想要查询一个变量，就要进行寻址，而连续的内存可以大大降低寻址的时间复杂度（比如数组只需要寻址一次，查到数组第一个元素位置就能访问这个数组），而链表结构则需要反复寻址，效率低下。</p>
<h3 id="8-三目运算符"><a href="#8-三目运算符" class="headerlink" title="#8 三目运算符"></a>#8 三目运算符</h3><p>很不起眼的一个小东西，刚开始的时候我以为仅仅是用来简化代码的，后来发现它能带来巨量的性能增幅<br>例如在做 并查集 的时候需要的 find函数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;   </span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这一份代码已经十分优秀，但是：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==fa[x]?x:fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这一份代码在比较普遍的 1e5 规模的数据下能够带来100ms左右的性能提升。</p>
<h3 id="9-使用指针"><a href="#9-使用指针" class="headerlink" title="#9 使用指针"></a>#9 使用指针</h3><p>这应该算是一个常识<br>之前看到有人写代码的时候这个样子<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直接将数组作为参数传递给了函数<br>这是一个相当愚蠢的行为，就好比，别人向你借书，然后你把书抄了一份给他。<br>显然应当直接把书借给他。<br>所以只需要告诉函数该数组的位置就好了，其实就是把第一个元素的位置告诉函数（因为数组使用的是连续内存嘛）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> *a)</span></span>&#123;  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">           ......	</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-读入优化-amp-输出优化"><a href="#10-读入优化-amp-输出优化" class="headerlink" title="#10 读入优化&amp;输出优化"></a>#10 读入优化&amp;输出优化</h3><p>很显然，任何一个题都需要输入输出，数据量大的话，至少要花费O(n)时间来读入（输出）数据。<br>其实读入（输出）优化的核心就是使用getchar();(putchar();)。因为这两种方法是最快的读入（输出）函数。</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>快读：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _TP&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_TP &amp;X)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">int</span> w;X=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;w=ch==<span class="string">&#x27;-&#x27;</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">    X=w?-X:X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出同理，因为不常用，就不附代码了。</p>
<h3 id="11-位运算-amp-状态压缩"><a href="#11-位运算-amp-状态压缩" class="headerlink" title="#11 位运算 &amp; 状态压缩"></a>#11 位运算 &amp; 状态压缩</h3><p>此二者内容颇多，便不细讲，附实例<br>位运算优化：<a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树 1</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _TP&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_TP &amp;X)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;<span class="keyword">int</span> w;X=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;w=ch==<span class="string">&#x27;-&#x27;</span>;ch=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">	X=w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> sum,lag;</span><br><span class="line">&#125;t[inf&lt;&lt;<span class="number">2</span>]; </span><br><span class="line"><span class="keyword">int</span> a[inf];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>].lag+=t[k].lag;</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lag+=t[k].lag;</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>].sum+=t[k].lag*(t[k&lt;&lt;<span class="number">1</span>].r-t[k&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">	t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=t[k].lag*(t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">	t[k].lag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	t[k].l=l;</span><br><span class="line">	t[k].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		t[k].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>,l,m);</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,m+<span class="number">1</span>,r);</span><br><span class="line">	t[k].sum=t[k&lt;&lt;<span class="number">1</span>].sum+t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r,<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r)&#123;</span><br><span class="line">		t[k].lag+=x;</span><br><span class="line">		t[k].sum+=x*(t[k].r-t[k].l+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[k].lag)push_down(k);</span><br><span class="line">	<span class="keyword">int</span> m=(t[k].l+t[k].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=m)change(k&lt;&lt;<span class="number">1</span>,l,r,x);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;m)change(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x);</span><br><span class="line">	t[k].sum=t[k&lt;&lt;<span class="number">1</span>].sum+t[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r)&#123;</span><br><span class="line">		ans+=t[k].sum;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[k].lag)push_down(k);</span><br><span class="line">	<span class="keyword">int</span> m=(t[k].r+t[k].l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=m)sum(k&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;m)sum(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n,x,l,r,q;</span><br><span class="line">	<span class="keyword">int</span> opt;</span><br><span class="line">	read(n);read(q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		read(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		read(opt);</span><br><span class="line">		<span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				read(l);read(r);read(x);</span><br><span class="line">				change(<span class="number">1</span>,l,r,x);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				read(l);read(r);</span><br><span class="line">				ans=<span class="number">0</span>;</span><br><span class="line">				sum(<span class="number">1</span>,l,r);</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>位运算优化：<a href="https://www.luogu.com.cn/problem/P3368">【模板】树状数组 2</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x)&amp;-(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,c[inf];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		ans+=c[p];</span><br><span class="line">		p-=lowbit(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;=n)&#123;</span><br><span class="line">		c[p]+=x;</span><br><span class="line">		p+=lowbit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,opt,l,r,x,ox=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		insert(i,x-ox);</span><br><span class="line"> 		ox=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line">		<span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span> :&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">				insert(l,x);</span><br><span class="line">				insert(r+<span class="number">1</span>,-x);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span> :&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;sum(x)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希前缀和</title>
    <url>/2019/02/01/%E5%93%88%E5%B8%8C%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>&ensp;&ensp;&ensp;&ensp;很早之前听说了这个算法，上个暑假zyz学长教会了我，前一阵字考试用到了差点忘记怎么写，好像这个方法知道的人也不多，特地写一写<br>&ensp;&ensp;&ensp;&ensp;<br>哈希前缀和，顾名思义就是哈希算法和前缀和结合起来。我们都知道哈希能够将一段字符串转换成一个整数，由此可以判断两段字符串是否相等例如模板题:<a href="https://www.luogu.org/problem/P3370">P3370 【模板】字符串哈希</a>。<br>&ensp;&ensp;&ensp;&ensp;<br>但其实仅仅如此的话哈希算法的用处还是有限的，因为比较简单的情况下可以使用set等等STL容器可以一定程度上替代他的功能，比较复杂的操作可以用&ensp;字典树&ensp;加上&ensp;树形dp&ensp;来解决。但是对于很多不熟悉STL的人来说不失为一个好办法。<br>&ensp;&ensp;&ensp;&ensp;<br>但是如果哈希和前缀和联系起来他的用处就大多了，有了它你甚至不需要学复杂的KMP。<br>&ensp;&ensp;&ensp;&ensp;<br>对于普通的哈希算法而言：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">      res=res*base+s[i];    <span class="comment">//一般情况下base选用131，当然也可以是其他</span></span><br><span class="line">      res%=p;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//p是一个比较大的数，一般选用大质数，但实际上如果你懒得模  </span></span><br><span class="line">   <span class="comment">//完全可以选择自然溢出，冲突的关键在于base而不是模数</span></span><br><span class="line">   <span class="comment">//例如 unsigned long long res;完全没有必要去 mod p了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&ensp;&ensp;&ensp;&ensp;<br>这样子就可以很容易的得到一段字符串的哈希值了<br>&ensp;&ensp;&ensp;&ensp;<br>但是这样时间复杂度是o(n),有没有可能o(1)呢，观察代码我们发现，如果有一个字符串 <strong>s</strong> 你想知道 s[1]~s[5],s[2]~s[6] 的哈希值，你发现其中的 s[2]~s[5] 的哈希值被重复计算了。自然我们想用前缀和优化。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=l;i--)&#123;</span><br><span class="line">		h[i]=h[i+<span class="number">1</span>]*<span class="number">131</span>+s[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> l,<span class="keyword">const</span> <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[l]-h[r]*base[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure><br>代码如上</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>国有企业的整体规划</title>
    <url>/2020/05/11/%E5%9B%BD%E6%9C%89%E4%BC%81%E4%B8%9A%E7%9A%84%E6%95%B4%E4%BD%93%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><p><strong>注</strong> : 在中国，本文所说的政府等同于执政党，在多党制国家，请将文中所说的政府替换为执政党。</p>
<h2 id="1-前置：国有企业与政治"><a href="#1-前置：国有企业与政治" class="headerlink" title="#1 前置：国有企业与政治"></a>#1 前置：国有企业与政治</h2><h3 id="1-1-0-劳动力资本"><a href="#1-1-0-劳动力资本" class="headerlink" title="#1.1.0 劳动力资本"></a>#1.1.0 劳动力资本</h3><p>&ensp;&ensp;&ensp;&ensp;&ensp;我认为劳动力是某种意义上的资本。因为劳动力可以生出劳动力，即将劳动力投入工厂，赚了钱，喂饱了工人，你将获得新的劳动力。这与资本的运作方式有一定的相似之处。所以工人某种意义上也是小的资本家。<br><strong>注</strong> ：此观点不一定适用于其他情况，不可随便引用。这里仅仅为了论述下文之观点。   </p>
<h3 id="1-1-1-资本与政治"><a href="#1-1-1-资本与政治" class="headerlink" title="#1.1.1 资本与政治"></a>#1.1.1 资本与政治</h3><p>&ensp;&ensp;&ensp;&ensp;&ensp;马克思说，经济基础决定上层建筑，在阶级史观下，资本主义政权的建立是因为资产阶级经济地位上升。也就是说<strong>资产阶级占有了国家大部分的资产</strong>。同样的，工人的劳动力从某种意义上也可以看作资本，那么无产阶级政权的建立，也是因为工人数量的增加导致的工人经济地位上升造成的结果。  </p>
<p>&ensp;&ensp;&ensp;&ensp;西方某位经济学家说，如果你欠银行十万美元，那你就有麻烦了。如果你千银行十亿美元，那银行就有麻烦了。我曾经做过一个假设，如果一个人（<strong>L先生</strong>）有了一吨黄金，并将其展示给公众，承诺给向他存钱的人100%的利息。以此扩大资金池，并不断吸纳更多人存钱，同时支付储户利息。以此引发人民疯狂向其中投资，以至于将全国绝大部分的钱都吸纳了进去。那么，如果此时<strong>L先生</strong>组建一支军队，要求夺取国家政权，那么他将是无往而不利的。因为他的士兵知道，如果失败那么他们将一贫如洗。而国家的士兵将是不可能胜利的。因为他们知道，如果胜利，他们将一贫如洗。（仅仅是一个片面的假设，这里认为假设国家找不到<strong>L先生</strong>的资产并不能收归国有并发还民众，且人民智商较低）  </p>
<p>&ensp;&ensp;&ensp;&ensp;当然，这个假设在现实中不可能发生，不说国家不允许非法集资，人民也不可能这么傻，把全部的钱都投进去。<br>&ensp;&ensp;&ensp;&ensp;但是，这个极端模型可以说明资本与政权的关系。就是国家政权的基础实际上是国家资本。也就是说，民众信任政府，实际上信任的是政府的资本（政府执政能力会直接导致其资本的升降，故以资本概括）。也就是我们下文说的政府的信任资本。</p>
<h3 id="1-1-2-信任资本"><a href="#1-1-2-信任资本" class="headerlink" title="#1.1.2 信任资本"></a>#1.1.2 信任资本</h3><p>&ensp;&ensp;&ensp;&ensp;解释一下这个概念，银行的信任资本应该比较明确，类比一下，这里说的信任资本就是向民众证明你的实力。对于国家来说，信任资本就是政府的资本。  </p>
<h3 id="1-1-3-中西方政治模式差异"><a href="#1-1-3-中西方政治模式差异" class="headerlink" title="#1.1.3 中西方政治模式差异"></a>#1.1.3 中西方政治模式差异</h3><h4 id="1-1-3-1-多党制政治模式内核"><a href="#1-1-3-1-多党制政治模式内核" class="headerlink" title="#1.1.3.1 多党制政治模式内核"></a>#1.1.3.1 多党制政治模式内核</h4><p>&ensp;&ensp;&ensp;&ensp;西方资本主义多党制，实际上是本国的不同的资本团体的利益有矛盾，而产生的利益集团。其表现就是财团与政党。<br>&ensp;&ensp;&ensp;&ensp;他们的运作模式其实就是你行你上的原则，当某个党派的支持着增多时，实质上就是更多的人的利益于其一致，所以执政党是代表大多数人的利益的。也可以说是代表大多数资本家的利益的。<br>&ensp;&ensp;&ensp;&ensp;由此可以用政党更替的合法性来保证政体的稳定。</p>
<h4 id="1-1-3-2-一党专制模式内核"><a href="#1-1-3-2-一党专制模式内核" class="headerlink" title="#1.1.3.2 一党专制模式内核"></a>#1.1.3.2 一党专制模式内核</h4><p>&ensp;&ensp;&ensp;&ensp;一党专制运作模式较为简单，就是保证国有资产占绝对优势地位。即国有企业。中国的国有经济（包括集体经济）就像是一个巨大的公司。只不过公司不是个人的，它的股东是人民（政府）。一党专制下，政府会通过国家强制力保障国有企业的统治地位。</p>
<h3 id="1-1-4-国有企业与政治"><a href="#1-1-4-国有企业与政治" class="headerlink" title="#1.1.4 国有企业与政治"></a>#1.1.4 国有企业与政治</h3><p>&ensp;&ensp;&ensp;&ensp;政府统治的基础是资本。在中国，政府统治的基础就是国有资本。所以说，国有企业就是中国政府生存的基石。这一点实际上在<strong>#1.1.3.2</strong> 中就说过了。<br><strong>注</strong> : 此处也算上国有资本入股的部分。</p>
<h2 id="2-国有企业与经济"><a href="#2-国有企业与经济" class="headerlink" title="#2 国有企业与经济"></a>#2 国有企业与经济</h2><h3 id="2-1-1-国有经济的弊端"><a href="#2-1-1-国有经济的弊端" class="headerlink" title="#2.1.1 国有经济的弊端"></a>#2.1.1 国有经济的弊端</h3><h4 id="2-1-1-1-国有经济的运作模式"><a href="#2-1-1-1-国有经济的运作模式" class="headerlink" title="#2.1.1.1 国有经济的运作模式"></a>#2.1.1.1 国有经济的运作模式</h4><p>&ensp;&ensp;&ensp;&ensp;早在二十世纪末，中国就搞过城市经济体制改革。改革一直进行至今。当时的主要思路就是两权分离，即所有权和管理权的分离。在这以前，国企主管基本都是政府官员。为什么要这样，原因相当的简单，无论东西方，资本家的产业越多，他就越不可能事必躬亲的进行管理，所以就要所有权和管理权分离。<br>&ensp;&ensp;&ensp;&ensp;两权分离的目的是为了提高员工（包括管理层）的办事效率与办事能力。而两权分离的方式一是股权改制，即管理层和技术人员控制一部分股份，以此激发起工作积极性。二是高新聘请管理层及技术人员。<br>&ensp;&ensp;&ensp;&ensp;我认为，这两种方式本质上没什么区别，即高薪聘请管理层和技术人员，本质上相当于给公司入了干股，公司效益提升了，势必要更高的薪资来留住人才。这样子和入了干股没啥区别。并且其还有一定的决策权。本质上和股权改制也没啥区别了。</p>
<h4 id="2-1-1-2-造成的严重问题"><a href="#2-1-1-2-造成的严重问题" class="headerlink" title="#2.1.1.2 造成的严重问题"></a>#2.1.1.2 造成的严重问题</h4><p>&ensp;&ensp;&ensp;&ensp;很显然，这样子就会造成私有资本上升，造成政府信用资本下降，动摇政府的统治基础。实苏联时期的历史就是我上述的过程。最终造成的后果就是寡头干政。国家分崩离析。<br>&ensp;&ensp;&ensp;&ensp;但要是不进行改制，经济就会停滞不前。</p>
<h4 id="2-1-1-3-解决方法"><a href="#2-1-1-3-解决方法" class="headerlink" title="#2.1.1.3 解决方法"></a>#2.1.1.3 解决方法</h4><p>&ensp;&ensp;&ensp;&ensp;防止经济停滞不前，方法就是现在正在倡导的减政放权。和允许多种经济形式并存。<br>&ensp;&ensp;&ensp;&ensp;但这种行为必须要掌握好度才行，因为上面说的种种问题…所以对于政府的要求很高，我觉得像现在中国的习总政府这样的水平高的政府实在是很难得的，现在公务员待遇变差了，人们都不愿意区政府工作，势必造成政府水平下降。所以我很担心下几代政府是否能挑起大梁来。</p>
<h2 id="2-1-2-国有经济的优势"><a href="#2-1-2-国有经济的优势" class="headerlink" title="#2.1.2 国有经济的优势"></a>#2.1.2 国有经济的优势</h2><p>&ensp;&ensp;&ensp;&ensp;1949年，上海金融风暴，留在上海没有去台湾的一批资本家联合起来，买空上海粮食等必需品，囤积在仓库里，企图抬高物价，然后在抛售以获取利益。然而，等到物价上去了，政府从全国各地调集粮食供应上海，稳定物价，一批资本家就此被套牢，一波血亏。这能体现出什么呢？国有企业有些像古代的官营手工业，市场化程度小，有国家力量支持。这成为了其最大的优势。改革开放以来，政府在某种意义上进行了经济，文化等多方面的保护。比如说防火墙护住了腾讯百度。如果没有防火墙中国的互联网行业不可能有现在的状况。<br>那么，为了防止外资损害民资利益，还有什么方法吗?<br>&ensp;&ensp;&ensp;&ensp;靠国企。国家支持下，国有企业不用担心财政，用钱堆出来技术实力，同外企竞争，这不失为一种好办法。<br>&ensp;&ensp;&ensp;&ensp;国企做先锋，把最困难的部分攻下来，再以此带动一批下游行业发展，有了肥沃的土壤，民资也会借助下游企业的良好环境随即发展起来。    </p>
<h2 id="2-1-3-私有经济的弱小"><a href="#2-1-3-私有经济的弱小" class="headerlink" title="#2.1.3 私有经济的弱小"></a>#2.1.3 私有经济的弱小</h2><p>&ensp;&ensp;&ensp;&ensp;受到国家、国有企业的限制，中国的私有经济不同于欧美的强大，他们中能够有能力进行的大规模的科研项目的少之又少。所以中国科研实力若也不是没有原因的。</p>
<h2 id="3-国有企业的整体规划"><a href="#3-国有企业的整体规划" class="headerlink" title="#3 国有企业的整体规划"></a>#3 国有企业的整体规划</h2><p>&ensp;&ensp;&ensp;&ensp;综上所述，我认为国有企业的任务就是承担起行业内老大个的任务，首先要承担社会责任，比如制定行业标准等等。<br>&ensp;&ensp;&ensp;&ensp;其次就是要保证国有资产在社会总资产中的绝对地位。目前政府的措施有对私企注入国资，对外企注入国资等等。<br>&ensp;&ensp;&ensp;&ensp;第三就是国家一定要对于高精尖的行业进行大力的投资，比如量子行业，人工智能，核能，航天等等。首先要做的就是通过国企来带动下游工业，也就是相关行业的私企发展。培养出温床，如此一来，高精尖行业的私企才会涌现出来。其次要做的就是培养科研人才，将他们分配到国有实验室和私企实验室从事研究工作，带动技术发展。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>&ensp;&ensp;&ensp;&ensp;总之，国有企业应当是大哥一样的存在，对私企、外企，我罩着你们，我帮你们斩荆棘，暴霜露，开疆拓土。但是你们必须必须得服从我的权威，要是那个翅膀长硬了别怪我揍你。<br>&ensp;&ensp;&ensp;&ensp;这，就是目前国有企业的整体规划。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>省实验技术部工作日志</title>
    <url>/2019/10/12/%E7%9C%81%E5%AE%9E%E9%AA%8C%E6%8A%80%E6%9C%AF%E9%83%A8%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h1 id="1-山东省实验中学服装模特大赛宣传片片头"><a href="#1-山东省实验中学服装模特大赛宣传片片头" class="headerlink" title="#1 山东省实验中学服装模特大赛宣传片片头"></a>#1 山东省实验中学服装模特大赛宣传片片头</h1><p>@2018.6<br>高一上学期进入团总支信息技术部，开始接触并自学视频制作。这是第一次有机会独立完成视频项目。我负责制作省实验服装模特大赛宣传片片头部分。<br>片头使用AE制作，由于技术不甚成熟，制作时套用模板。<br>与其说完成任务，倒不如说是完成学习，作为一个初学者，我所能做的就是遇到问题，解决问题，再遇到问题…<br>边学边做，收获颇丰。借用我部长的一句话：经过这次的项目我已经可以独挡一面。</p>
<p><big>ATTATION：由于过于久远，完整视频已丢失，只找到部分</big></p>
<p><big>原创视频 使用LOFTER作为视频服务器</big></p>
<p><big>播放前请点击左上关闭音乐</big></p>
<p><video id="video" controls="" preload="none" poster="https://s2.ax1x.com/2019/12/16/Q52zPH.jpg"><br>    <source id="mp4" src="http://vodm2lzexwq.vod.126.net/vodm2lzexwq/E0LLNUTl_2843128489_sd.mp4?resId=254486990bfa2cd7aa860229db639341_2843128489_1&sign=m3rlA%2FVvgNved9ypwtBg0jeWz6i9UTWFqtRbHmCWWxg%3D" type="video/mp4">
    </video>  </p>
<h1 id="2-校义卖节蒲公英社团海报"><a href="#2-校义卖节蒲公英社团海报" class="headerlink" title="#2 校义卖节蒲公英社团海报"></a>#2 校义卖节蒲公英社团海报</h1><p>@2019.6<br>实话说海报打印出来的时候我还是挺佩服我自己的因为本来这个任务分给了我部门里的一个高一同学，没想到她那里出了问题，到头来还是得我亲自做海报，时间也相当的更赶。<br>刚开始确实是一点思路都没有，大课间在学校机房里疯狂查资料，跑遍了各大素材网站，找到了一些素材,先找蒲公英，就找出了背景图，后来和蒲公英社团的负责人了解到他们想要流程图，还想要在义卖节打擂台……<br>初步形成了目前的构架，之后花了两天晚上的时间，和蒲公英社的负责人沟通外加制作，终于赶在义卖节之前印出来了海报。不容易。<br>个人觉得比较值得称道的就是下半部分的游戏介绍，自然！（国外某公益活动的海报上找到的灵感）<br>不过，实话说什么时候中国的那些死板的又红又专毫无美感的海报能够被精心设计…不过比起前几年是好多啦！<br>之间还发生了一点小插曲，现在海报的尺寸是用在易拉宝上的，而刚开始做的时候是按照 4:3 做的，后来优化了一些时间改成了现在的样子</p>
<h2 id="海报本尊"><a href="#海报本尊" class="headerlink" title="海报本尊"></a>海报本尊</h2><p><img src="https://s2.ax1x.com/2019/12/20/QLggvF.png" alt="avatar"></p>
<h1 id="3-新高一学校开放日团总支选宣传海报"><a href="#3-新高一学校开放日团总支选宣传海报" class="headerlink" title="#3 新高一学校开放日团总支选宣传海报"></a>#3 新高一学校开放日团总支选宣传海报</h1><h2 id="学校开放日："><a href="#学校开放日：" class="headerlink" title="学校开放日："></a>学校开放日：</h2><p>每年中考之后，学校都会组织开放日活动，供中考完的准高中生们参观，借以增加学校的知名度和吸引学生报考，虽说省实验分数线一直稳居济南市第一，但也免不了搞一番活动。<br>因为去年开放日的时候我就有打算张贴海报进行团总支的宣传，但由于种种原因没能实现，而去年团总支的宣传工作确实不是非常的有力。故而今年做了两张海报分别对团总支&amp;信息技术部进行宣传。</p>
<h2 id="团总支海报"><a href="#团总支海报" class="headerlink" title="团总支海报"></a>团总支海报</h2><p><img src="https://s2.ax1x.com/2019/12/20/QL6GVI.png" alt="avatar"></p>
<h2 id="技术部海报"><a href="#技术部海报" class="headerlink" title="技术部海报"></a>技术部海报</h2><p><img src="https://s2.ax1x.com/2019/12/20/QL6YIP.png" alt="avatar"><br>这两张海报几乎是一天一张的速度，也是挺佩服我自己了  </p>
<h1 id="4-退休咯"><a href="#4-退休咯" class="headerlink" title="#4 退休咯"></a>#4 退休咯</h1><p>两年工作经验让我从萌新蜕变成了老司机，感谢团总支提供给我的锻炼的机会。<br>也希望团总支能越来越好，技术部能越来越好！！</p>
]]></content>
      <tags>
        <tag>数字媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>进制转换问题详解</title>
    <url>/2019/07/16/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<p>ATTAINTION: 由于HEXO目前对于MathJax的支持不甚完善，所以本篇数学公示渲染缺乏美观<a href="https://www.luogu.com.cn/blog/RF-YZZS/jin-zhi-zhuai-huan">我的LUOGU博客</a>以获最佳体验</p>
<h1 id="关于进制转换的问题最详细解释"><a href="#关于进制转换的问题最详细解释" class="headerlink" title="关于进制转换的问题最详细解释"></a>关于进制转换的问题最详细解释</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>很久前曾经系统学习过进制转换的问题，但发现…忘了？！好吧所以就再重新学习下然后写篇博客吧。<del>这次可不要再不求甚解了。</del></strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;<br>那么就开始吧，先说下最基础的，如何把十进制数 <strong>a</strong> 转化为任意正 <strong>r</strong> 进制数。<br>&ensp;&ensp;&ensp;&ensp;在十进制下 $\forall$ n $\in$ Z ，都可以将它表示为<br>$A_1\times10^{n-1}+A_2\times10^{n-2}+…+A_n\times10^{0}$，其中 ${A}_{i}\in{Z}^{+}$ ，其中的 ${A}_{i}$ 就是这个整数每一位的值。很显然的可以对它进行推广，$\forall$ r $\in$ R 都有以上结论成立。很显然我们要做的就是获得在 r 进制下的$A_i$的值。获得方法也很简单。那就是将这个整数对 r 不停地取模，然后将它除以 r 向下取整。稍微考虑下就可以发现它的原理(如果是特殊情况的话需要稍加更改，比如负进制)。<br>&ensp;&ensp;&ensp;&ensp;下面举个简单的例子，将十进制下的 6 转换为二进制。按照刚才的步骤，将其对 2 取模，发现是零，这里的意义其实就是， 6 在二进制下的最后一位是 0 ，因为它 % 2 为零，就说明它不需要 $2^0$ 这个数所以这一位为0，就是我们上面所讲$A_1$=0。的这是很显然的。然后让 6 / 2 得到 3 这就相当于对于 6 的二进制数忽略掉最后一位重复刚才的过程。因为100（base2）相当于10*2（base2）对吧。那么再让 $3\%2$ ,得到 1 ，刚才讲到，这里的 1 默认是乘以二的所以就说明 6 需要 $2^{0+1}$ 就是$2^1$，那么1就是前面我们所讲到的$A_{2}$。我们一直重复刚才的过程就可以得到 6 的二进制表示：110；</p>
<p>&ensp;&ensp;&ensp;&ensp;即为$1 \times 2^{2}+1 \times 2^{1}+0 \times 2^{0}$很简单吧^_^</p>
<p>下面贴一段代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,r;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;r);   <span class="comment">//十进制数 n 再 r 进制下 </span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		t=n%r;</span><br><span class="line">		s.push(t);     <span class="comment">//因为我们是从后向前计算的,所以就用个栈存下</span></span><br><span class="line">		n/=r;              <span class="comment">//c++向零取整</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="输入：6-2"><a href="#输入：6-2" class="headerlink" title="输入：6 2"></a>输入：6 2</h4><h4 id="输出：110"><a href="#输出：110" class="headerlink" title="输出：110"></a>输出：110</h4>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>赤梦</title>
    <url>/2019/10/22/%E8%B5%A4%E6%A2%A6/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="赤梦·成长"><a href="#赤梦·成长" class="headerlink" title="赤梦·成长"></a>赤梦·成长</h2><h3 id="—记17级6班微电影后期"><a href="#—记17级6班微电影后期" class="headerlink" title="—记17级6班微电影后期"></a>—记17级6班微电影后期</h3><h3 id="1-起因"><a href="#1-起因" class="headerlink" title="#1 起因"></a>#1 起因</h3><p>实话说一开始答应同学给班里的微电影做后期的时候想的是：多大点事，剪视频而已啦<br>电影节是省实验团总支举办的一年一度的活动，身在团总支的我当然要积极参与咯</p>
<h3 id="2-其实我是懵的"><a href="#2-其实我是懵的" class="headerlink" title="#2 其实我是懵的"></a>#2 其实我是懵的</h3><p>剪辑当然要有素材咯，经过我班同学坚苦卓绝的拍摄(拍摄的同学真的很努力，甚至还借来了无人机)呈现在我面前的是存在三个百度云账号上 <del>拍摄精良的</del> 稀碎的N个小短篇，花絮和片子混在一起…<br>然而屋漏偏逢连夜雨，交稿迫在眉睫给我的时间不足一周（不是假期）</p>
<h3 id="3-思路"><a href="#3-思路" class="headerlink" title="#3 思路"></a>#3 思路</h3><p>我觉得我无论是写东西还是做视频没有思路的情况往往是不知道怎么开头，一般而言如果有了开头，后面也就水到渠成了。( 不知道其他人是不是这样<br>于是就有了下面的开头<br>ps：我都不知道当时是怎么想的…脑溢血了嘛这是【笑哭】<br>不过同学反馈来说还是挺不错的  </p>
<h3 id="4-改编"><a href="#4-改编" class="headerlink" title="#4 改编"></a>#4 改编</h3><p>把零零碎碎的全都扔进 <strong>PR</strong> 里，我发现，先有的素材实在是…有限。</p>
<h4 id="剧本："><a href="#剧本：" class="headerlink" title="剧本："></a>剧本：</h4><p>大致上是这样的：陆天航（剧中小胖）因踢球技不如人被唐棣（剧中体委）嘲讽且铲伤，奋发图强努力训练还是收效甚微，直到听到暗恋的妹子的鼓励，突然打通任督二脉，球技爆发，在学校巅峰杯球赛中取得成功。却发现暗恋的妹子鼓励的是唐棣…<br>的故事(好惨</p>
<p>但是这样子叙事实在成问题，询问导演兼编剧兼制片的同学，他说：你看着办吧。我：？？？</p>
<p>然后剧本就被我改成了这样：陆天航（剧中小胖）因踢球技不如人被唐棣（剧中体委）嘲讽且铲伤，奋发图强努力训练还是收效甚微，直到听到暗恋的妹子的鼓励，突然打通任督二脉，球技爆发，在学校巅峰杯球赛中取得成功。悟透人间真谛。  </p>
<p>于是，就有了下面的微电影  </p>
<h3 id="4-5-建议登录后观看-ensp-ensp-播放前请点击左上关闭音乐"><a href="#4-5-建议登录后观看-ensp-ensp-播放前请点击左上关闭音乐" class="headerlink" title="#4.5 建议登录后观看&ensp;&ensp;播放前请点击左上关闭音乐"></a>#4.5 建议登录后观看<strong>&ensp;&ensp;</strong>播放前请点击左上关闭音乐</h3><iframe src="//player.bilibili.com/player.html?aid=61778982&cid=107427080&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="1024" height="576">
</iframe>

<h3 id="5-学习·实践中解决问题"><a href="#5-学习·实践中解决问题" class="headerlink" title="#5 学习·实践中解决问题"></a>#5 学习·实践中解决问题</h3><p>这次的工作对我来说更是学习，实话讲，在此之前，我只会用 AE 加 PS<br>这次之后，我学回了用 PR 作框架、剪辑，具体特效、细节处理用 AE ，图像处理用 AU ，音频编辑用 AU<br>PR————&gt; AE——&gt; PS<br>&ensp;&ensp;&ensp;&ensp;|——&gt; AU<br>由大到小，四方联动，真的很不错  </p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><p>&ensp;&ensp;&ensp;&ensp;开头有段陆天航的独白，视频里看是全黑的，但当时加了噪点。但因为压缩的原因没有了。以后需要考虑下压缩的问题。</p>
]]></content>
      <tags>
        <tag>数字媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>教工食堂游记</title>
    <url>/2018/10/12/%E6%95%99%E5%B7%A5%E9%A3%9F%E5%A0%82%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="教师食堂游记"><a href="#教师食堂游记" class="headerlink" title="教师食堂游记"></a>教师食堂游记</h2><p>&ensp;&ensp;&ensp;&ensp;前段时间，由同学向我普及教师食堂的风采，原因是某天他和他的数学老师讨论题，加上拖堂就到了十二点半，而此时，学生食堂以经没有饭了，那么顺理成章的，他的数学老师就请他到教工食堂共进午餐 <del>笑</del><br>我听闻觉得有点意思，想着什么时候我也能进去看看<br>然而，就在前天中午（2019.4.19）周五中午，在机房逃掉了信息课。出门遇到了高一的信息老师，然后呢…就又顺理成章开始聊天，显然，我应该问“您吃了吗”，更显然的事情就是，显然，我的老师没有吃饭。<br>那么就导致了很严重的问题，我就顺理成章的被请吃饭了，显然是教师食堂。<br>那么问题来了，里面全都是老师，所以就有了今天的《教师食堂游记》。<br>——————————————分割线——————————————</p>
<h2 id="正文开始："><a href="#正文开始：" class="headerlink" title="正文开始："></a>正文开始：</h2><p>&ensp;&ensp;&ensp;&ensp;首先，还没有进入教工食堂，我就意识到了一个问题，因为高一的广泛社交加之在学生团总支担任了信息技术部副部长一职，我认识巨量的老师。<br>但问题的关键就在于，级部主任，某丁丁姓主任，很不喜欢oier，同时也包括了教练们，虽然只有一个所以刚进入教工食堂，我就接收到了丁丁主任的冷酷的目光，丁丁主任在和一桌子主任谈笑风生，然后奇迹般的变脸，又变了回去，吓得我赶紧转过了头…<br>然后显然就要开始打饭的活动，我抬头发现遇到了国际部某班主任老师（语文老师emmm）正带着他的孩子打饭，然后，顺理成章的一番客套，我点了两个素菜一个米饭，被老师强迫加菜，很显然，是最后依然只有这两个菜。<br>一转眼，我发现很多老师都在成群结队的谈笑风生，漠然发现了孤独的任姓老师，我端着餐盘走过，他亲切地问我，我请你喝粥啊~~<br>显然，我不能被请喝粥，因为粥是免费的。但我感受到了老师的好意，内心充满了满足。<br>随后就是漫长的吃饭时间，我被询问了某姓中学学习环境。<br>我说，育英中学好轻松啊，作业很少的<br>之后一番聊天，老师们渐渐少了，这时，我蓦然发现，国际部的语文老师班主任正在和她的孩子谈论人生观价值观世界观，社会学政治学，教育科学哲学<br>就是没有哲学♂<br>我大惊，这孩子如果没有上某嘤姓中学，必然要当国家主席啊<br>然后，我被我的信息老师强迫吃饭，她并没有意识到我这么瘦弱，一定是吃不完的<br>我考虑了一下，发现一个两岁孩子的母亲好像会强迫任何人吃饭…<br>很显然，最后我依然没有把饭吃完<br>然而，整个里层食堂就剩下国际部的语文老师班主任，我的信息老师，还有…高导？！在默默地玩着手机 emmm<br>又是顺理成章的，我收拾了餐盘，准备离开教工食堂<br>但是，就在我进入外层食堂的时候，遇到了某铝主任，和他可爱的同样在某中学的女儿在吃饭。我心中一紧，赶忙问好<br>显然，铝叫住了我“你过来！！！！”<br>我：“？？？”<br>铝：“你怎么进来的？”<br>我的信息老师：“啊，我带他来的”<br>我心中的van分感激<br>之后<br>铝：“你还想不想交作业”<br>我：“？？？”<br>我：“老师，我有什么作业没有交吗”<br>铝思考了一下: “最近没有…”<br>铝：“那以前呢？！！！！！”<br>我石化了<br>我：“以前确实有几次”<br>我发现我的信息老师早已退后至安全距离<br>铝：“你还行不想交作业”<br>我：“想”<br>铝：“那好，要想交就老老实实…”<br>我怀着沉重的心情走出了教工食堂我在学妹面前的形象毁于一旦<br>【完】<br>——————————正文结束——————————</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1008 【三连击】</title>
    <url>/2018/10/12/%E9%A2%98%E8%A7%A3%20P1008%20%E3%80%90%E4%B8%89%E8%BF%9E%E5%87%BB%E3%80%91/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="Next-permutation"><a href="#Next-permutation" class="headerlink" title="Next_permutation();"></a>Next_permutation();</h2><p><strong>借这个题熟悉下next_permutation()的用法</strong><br>这个函数主要就是把英语记住其他就和sort差不多的用<br>如果已经到了最后一个序列就会返回false。<br>next_ per mu ta tion ~~<br>每次执行一次就会将原有的序列打乱成下一个序列</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><p>&ensp;&ensp;&ensp;&ensp;另外还有一点就是，next_premutation()函数是什么，按照字面意思，就是下一个排列，那么考虑一个问题，如果当前排列不是第一个排列呢（关于第几个排列的问题如果不懂的请百度下泰勒展开），就会有他的孪生兄弟：prev_permutation()用法一样，只是求出的是上一个序列。一个序列的第一个排列就是他的升序排列<br>&ensp;&ensp;&ensp;&ensp;<br>幸好这个题给的数据都是排过序的。所以说对于无序的序列来讲，可以先next_permutation()+perv_permutation();或者先排个序然后再next_permutation();就可以求出全部的排列了。</p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> next_a=a[<span class="number">0</span>]*<span class="number">100</span>+a[<span class="number">1</span>]*<span class="number">10</span>+a[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> next_b=a[<span class="number">3</span>]*<span class="number">100</span>+a[<span class="number">4</span>]*<span class="number">10</span>+a[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> next_c=a[<span class="number">6</span>]*<span class="number">100</span>+a[<span class="number">7</span>]*<span class="number">10</span>+a[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">if</span>(next_a*<span class="number">3</span>==next_c &amp;&amp; next_a*<span class="number">2</span>==next_b)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;next_a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;next_b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;next_c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(a,a+<span class="number">9</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>题解【射击】— 枚举，不只是暴力！</title>
    <url>/2020/01/31/%E9%A2%98%E8%A7%A3%E3%80%90%E5%B0%84%E5%87%BB%E3%80%91/</url>
    <content><![CDATA[<p>点击左上关闭音乐&ensp;</p>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&ensp;&ensp;&ensp;&ensp;CSP2019的前一天，早起到了学校。今天是高三二诊的第一天，恰好CSP和二诊冲掉了，不得已请了假。本来高三是不打算停课的，借此机会重温了一下子机房停课的快乐生活。停一天也是停嘛。<br>&ensp;&ensp;&ensp;&ensp;到了学校发现教练还没到，可能是我太久没有机房停课的生活，忘记了机房的生物钟了。一群人在实验楼连廊里等教练。等到大约八点半教练终于来上班了。（中间还被级部主任误以为是逃考试的学生……<br>&ensp;&ensp;&ensp;&ensp;看完了教练发的一套题，感觉挺简单的，做完了还没到中午放学，扭头看旁边同学在干什么，发现我的两个同学(均为高三)在研究一道题。<del>(主角出场</del></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><h3 id="ATTATION"><a href="#ATTATION" class="headerlink" title="ATTATION:"></a>ATTATION:</h3><p>题目过于久远，已经不记得具体是什么了。题目在NOIOJ上面，现在这个网站挂掉了所以题面是我根据之前的代码以及依稀的印象反向编的。<br><del>（似乎什么时候听说NOIP会从题库里出原题来着？那我就盲猜一把射击这个题 2020.1.31</del> …好了，事实证明NOIP取消了，CSP：我和NOIP没有（you）关系</p>
<h3 id="题面："><a href="#题面：" class="headerlink" title="题面："></a>题面：</h3><p>一共有N种物品（N&lt;=5e3），你有放回的取4次，每一次可以不取，也可以取 i ，每个物品有权值ai，求四次取到的和比m小的最大值是多少 (0&lt;m&lt;Max_long long,0&lt;ai&lt;MAX_int)</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>因为m的值非常大，所以没办法背包。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先，这道题是绝世好题。<br>我记得之前做题的时候见到一道题 <a href="https://www.luogu.com.cn/problem/P3396">P3396 哈希冲突</a> 题解里说这道题是一篇省选论文里的，论文说：根号算法，不只是分块。(这也是一道绝世好题)</p>
<p>那么我也要说，今天的这道题 <strong>射击</strong> 是：枚举算法，不只是暴力。<br>这道题第一眼看来没什么思路，首先写搜索，大力剪枝之后最多只能拿到40分<br>搜索的复杂度是O(n^4)，妥妥的TLE那怎么办呢？<br>先上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">1e6</span>+<span class="number">7</span>],ans;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _TP&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_TP &amp;X)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;<span class="keyword">int</span> w;X=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;w=ch==<span class="string">&#x27;-&#x27;</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">    X=w?-X:X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    read(n);read(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        read(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            a[n+k]=a[i]+a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+k+<span class="number">1</span>);</span><br><span class="line">    i=<span class="number">1</span>,j=n+k;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+a[j]&lt;=m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]+a[j]&gt;ans)ans=a[i]+a[j];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这就是完整的代码了，什么意思呢？<br>考虑这样一个问题，我们可以把过程看成两个取两次而不是一个取四次<br>这里实际上使用了分别枚举的技巧，也就是说，先对前两次进行O(n^2)的枚举<br>，记录状态，然后再对后两次取进行O(n^2)的枚举，记录状态。但实际上这两次枚举的结果是一模一样的，所以枚举一次就好了。<br>最后再对于前两次的结果进行一次O(n^2)的枚举。答案就有了。<br>这样看起来整体的复杂度是O(n^2)的，但是，最后一次枚举的时候实际上状态数量是O(n^2)的.其实最后一次的枚举复杂度是O（n^4）的。所以说其实复杂度并没有优化。<br><strong>枚举的代码是这样的：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">        ++k;</span><br><span class="line">        a[n+k]=a[i]+a[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>但是！</strong><br>进行了前两次枚举就可以用一种类似贪心的方法进行处理了，也就是<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(a+<span class="number">1</span>,a+n+k+<span class="number">1</span>);</span><br><span class="line">    i=<span class="number">1</span>,j=n+k;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]+a[j]&lt;=m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]+a[j]&gt;ans)ans=a[i]+a[j];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这样，最后一次的贪心是O(n^2)的。  </p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
